{"ast":null,"code":"/**\n * Utilidades de validación y sanitización\n */\n\n// Expresiones regulares para validación\nconst PATTERNS = {\n  email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/,\n  phone: /^[\\+]?[1-9][\\d]{0,15}$/,\n  currency: /^\\d+(\\.\\d{1,2})?$/,\n  alphanumeric: /^[a-zA-Z0-9\\s]+$/,\n  alphanumericSpanish: /^[a-zA-ZñÑáéíóúÁÉÍÓÚ0-9\\s]+$/,\n  password: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/,\n  url: /^https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)$/\n};\n\n/**\n * Función simple para sanitizar texto (reemplaza DOMPurify)\n */\nconst simpleSanitize = (input, allowBasicHTML = false) => {\n  if (typeof input !== 'string') return '';\n  let sanitized = input;\n  if (!allowBasicHTML) {\n    // Remover todas las etiquetas HTML\n    sanitized = sanitized.replace(/<[^>]*>/g, '');\n  } else {\n    // Solo permitir etiquetas básicas seguras\n    const allowedTags = ['b', 'i', 'em', 'strong', 'p', 'br'];\n    const tagPattern = /<\\/?([a-zA-Z][a-zA-Z0-9]*)\\b[^>]*>/g;\n    sanitized = sanitized.replace(tagPattern, (match, tagName) => {\n      return allowedTags.includes(tagName.toLowerCase()) ? match : '';\n    });\n  }\n\n  // Decodificar entidades HTML básicas\n  sanitized = sanitized.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&').replace(/&quot;/g, '\"').replace(/&#x27;/g, \"'\");\n  return sanitized;\n};\n\n/**\n * Sanitizar entrada de texto\n */\nexport const sanitizeText = input => {\n  if (typeof input !== 'string') return '';\n\n  // Eliminar HTML y normalizar espacios\n  const sanitized = simpleSanitize(input, false);\n\n  // Trim y normalizar espacios\n  return sanitized.trim().replace(/\\s+/g, ' ');\n};\n\n/**\n * Sanitizar entrada HTML\n */\nexport const sanitizeHTML = input => {\n  if (typeof input !== 'string') return '';\n  return simpleSanitize(input, true);\n};\n\n/**\n * Validadores específicos\n */\nexport const validators = {\n  required: value => ({\n    isValid: value != null && value !== '' && String(value).trim() !== '',\n    message: 'Este campo es requerido'\n  }),\n  email: value => ({\n    isValid: !value || PATTERNS.email.test(value),\n    message: 'Formato de email inválido'\n  }),\n  phone: value => ({\n    isValid: !value || PATTERNS.phone.test(value),\n    message: 'Formato de teléfono inválido'\n  }),\n  currency: value => {\n    const numValue = parseFloat(value);\n    return {\n      isValid: !value || PATTERNS.currency.test(value) && numValue >= 0,\n      message: 'Formato de moneda inválido'\n    };\n  },\n  positiveNumber: value => {\n    const numValue = parseFloat(value);\n    return {\n      isValid: !value || !isNaN(numValue) && numValue > 0,\n      message: 'Debe ser un número positivo'\n    };\n  },\n  minLength: min => value => ({\n    isValid: !value || value.length >= min,\n    message: `Mínimo ${min} caracteres`\n  }),\n  maxLength: max => value => ({\n    isValid: !value || value.length <= max,\n    message: `Máximo ${max} caracteres`\n  }),\n  pattern: (pattern, message) => value => ({\n    isValid: !value || pattern.test(value),\n    message\n  }),\n  alphanumericSpanish: value => ({\n    isValid: !value || PATTERNS.alphanumericSpanish.test(value),\n    message: 'Solo letras, números y espacios permitidos'\n  }),\n  password: value => ({\n    isValid: !value || PATTERNS.password.test(value),\n    message: 'La contraseña debe tener al menos 8 caracteres, una mayúscula, una minúscula, un número y un símbolo'\n  }),\n  url: value => ({\n    isValid: !value || PATTERNS.url.test(value),\n    message: 'URL inválida'\n  }),\n  dateRange: (startDate, endDate) => value => {\n    if (!value) return {\n      isValid: true\n    };\n    const date = new Date(value);\n    const start = startDate ? new Date(startDate) : null;\n    const end = endDate ? new Date(endDate) : null;\n    let isValid = true;\n    if (start && date < start) isValid = false;\n    if (end && date > end) isValid = false;\n    return {\n      isValid,\n      message: `Fecha debe estar entre ${start === null || start === void 0 ? void 0 : start.toLocaleDateString()} y ${end === null || end === void 0 ? void 0 : end.toLocaleDateString()}`\n    };\n  },\n  custom: (validatorFn, message) => value => ({\n    isValid: validatorFn(value),\n    message\n  })\n};\n\n/**\n * Validar objeto completo\n */\nexport const validateObject = (data, rules) => {\n  const errors = {};\n  let isValid = true;\n  Object.keys(rules).forEach(field => {\n    const value = data[field];\n    const fieldRules = Array.isArray(rules[field]) ? rules[field] : [rules[field]];\n    for (const rule of fieldRules) {\n      const result = rule(value);\n      if (!result.isValid) {\n        errors[field] = result.message;\n        isValid = false;\n        break; // Solo mostrar el primer error por campo\n      }\n    }\n  });\n  return {\n    isValid,\n    errors\n  };\n};\n\n/**\n * Esquemas de validación para la aplicación financiera\n */\nexport const schemas = {\n  expense: {\n    description: [validators.required, validators.minLength(3), validators.maxLength(100), validators.alphanumericSpanish],\n    amount: [validators.required, validators.positiveNumber],\n    category_id: [validators.required],\n    due_date: [validators.dateRange(new Date(), null)]\n  },\n  income: {\n    description: [validators.required, validators.minLength(3), validators.maxLength(100), validators.alphanumericSpanish],\n    amount: [validators.required, validators.positiveNumber],\n    category_id: [validators.required]\n  },\n  category: {\n    name: [validators.required, validators.minLength(2), validators.maxLength(50), validators.alphanumericSpanish],\n    description: [validators.maxLength(200)]\n  },\n  user: {\n    email: [validators.required, validators.email],\n    password: [validators.required, validators.password],\n    name: [validators.required, validators.minLength(2), validators.maxLength(50), validators.pattern(/^[a-zA-ZñÑáéíóúÁÉÍÓÚ\\s]+$/, 'Solo letras y espacios')]\n  }\n};\n\n/**\n * Funciones de sanitización específicas\n */\nexport const sanitizers = {\n  expense: data => ({\n    description: sanitizeText(data.description),\n    amount: parseFloat(data.amount) || 0,\n    category_id: parseInt(data.category_id) || null,\n    due_date: data.due_date ? new Date(data.due_date).toISOString().split('T')[0] : null,\n    paid: Boolean(data.paid)\n  }),\n  income: data => ({\n    description: sanitizeText(data.description),\n    amount: parseFloat(data.amount) || 0,\n    category_id: parseInt(data.category_id) || null\n  }),\n  category: data => ({\n    name: sanitizeText(data.name),\n    description: sanitizeText(data.description)\n  }),\n  user: data => ({\n    email: sanitizeText(data.email).toLowerCase(),\n    name: sanitizeText(data.name),\n    // Nota: Las contraseñas nunca deben sanitizarse, solo validarse\n    password: data.password\n  })\n};\n\n/**\n * Función helper para validar y sanitizar\n */\nexport const validateAndSanitize = (data, type) => {\n  // Sanitizar primero\n  const sanitizedData = sanitizers[type] ? sanitizers[type](data) : data;\n\n  // Luego validar\n  const schema = schemas[type];\n  if (!schema) {\n    return {\n      isValid: true,\n      data: sanitizedData,\n      errors: {}\n    };\n  }\n  const validation = validateObject(sanitizedData, schema);\n  return {\n    isValid: validation.isValid,\n    data: sanitizedData,\n    errors: validation.errors\n  };\n};\n\n/**\n * Rate limiting simple para formularios\n */\nclass FormRateLimit {\n  constructor() {\n    this.attempts = new Map();\n    this.cooldownPeriod = 60000; // 1 minuto\n    this.maxAttempts = 5;\n  }\n  canSubmit(formId) {\n    const now = Date.now();\n    const formAttempts = this.attempts.get(formId) || {\n      count: 0,\n      lastAttempt: 0\n    };\n\n    // Reset si pasó el período de cooldown\n    if (now - formAttempts.lastAttempt > this.cooldownPeriod) {\n      formAttempts.count = 0;\n    }\n    return formAttempts.count < this.maxAttempts;\n  }\n  recordAttempt(formId) {\n    const now = Date.now();\n    const formAttempts = this.attempts.get(formId) || {\n      count: 0,\n      lastAttempt: 0\n    };\n    formAttempts.count++;\n    formAttempts.lastAttempt = now;\n    this.attempts.set(formId, formAttempts);\n  }\n  getRemainingCooldown(formId) {\n    const formAttempts = this.attempts.get(formId);\n    if (!formAttempts || formAttempts.count < this.maxAttempts) {\n      return 0;\n    }\n    const elapsed = Date.now() - formAttempts.lastAttempt;\n    return Math.max(0, this.cooldownPeriod - elapsed);\n  }\n}\nexport const formRateLimit = new FormRateLimit();\nexport default {\n  sanitizeText,\n  sanitizeHTML,\n  validators,\n  validateObject,\n  schemas,\n  sanitizers,\n  validateAndSanitize,\n  formRateLimit\n};","map":{"version":3,"names":["PATTERNS","email","phone","currency","alphanumeric","alphanumericSpanish","password","url","simpleSanitize","input","allowBasicHTML","sanitized","replace","allowedTags","tagPattern","match","tagName","includes","toLowerCase","sanitizeText","trim","sanitizeHTML","validators","required","value","isValid","String","message","test","numValue","parseFloat","positiveNumber","isNaN","minLength","min","length","maxLength","max","pattern","dateRange","startDate","endDate","date","Date","start","end","toLocaleDateString","custom","validatorFn","validateObject","data","rules","errors","Object","keys","forEach","field","fieldRules","Array","isArray","rule","result","schemas","expense","description","amount","category_id","due_date","income","category","name","user","sanitizers","parseInt","toISOString","split","paid","Boolean","validateAndSanitize","type","sanitizedData","schema","validation","FormRateLimit","constructor","attempts","Map","cooldownPeriod","maxAttempts","canSubmit","formId","now","formAttempts","get","count","lastAttempt","recordAttempt","set","getRemainingCooldown","elapsed","Math","formRateLimit"],"sources":["/Users/pmelegatti/Development/Financial Resume/financial-resume-engine-frontend/src/utils/validation.js"],"sourcesContent":["/**\n * Utilidades de validación y sanitización\n */\n\n// Expresiones regulares para validación\nconst PATTERNS = {\n  email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/,\n  phone: /^[\\+]?[1-9][\\d]{0,15}$/,\n  currency: /^\\d+(\\.\\d{1,2})?$/,\n  alphanumeric: /^[a-zA-Z0-9\\s]+$/,\n  alphanumericSpanish: /^[a-zA-ZñÑáéíóúÁÉÍÓÚ0-9\\s]+$/,\n  password: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/,\n  url: /^https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)$/\n};\n\n/**\n * Función simple para sanitizar texto (reemplaza DOMPurify)\n */\nconst simpleSanitize = (input, allowBasicHTML = false) => {\n  if (typeof input !== 'string') return '';\n  \n  let sanitized = input;\n  \n  if (!allowBasicHTML) {\n    // Remover todas las etiquetas HTML\n    sanitized = sanitized.replace(/<[^>]*>/g, '');\n  } else {\n    // Solo permitir etiquetas básicas seguras\n    const allowedTags = ['b', 'i', 'em', 'strong', 'p', 'br'];\n    const tagPattern = /<\\/?([a-zA-Z][a-zA-Z0-9]*)\\b[^>]*>/g;\n    \n    sanitized = sanitized.replace(tagPattern, (match, tagName) => {\n      return allowedTags.includes(tagName.toLowerCase()) ? match : '';\n    });\n  }\n  \n  // Decodificar entidades HTML básicas\n  sanitized = sanitized\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&amp;/g, '&')\n    .replace(/&quot;/g, '\"')\n    .replace(/&#x27;/g, \"'\");\n  \n  return sanitized;\n};\n\n/**\n * Sanitizar entrada de texto\n */\nexport const sanitizeText = (input) => {\n  if (typeof input !== 'string') return '';\n  \n  // Eliminar HTML y normalizar espacios\n  const sanitized = simpleSanitize(input, false);\n  \n  // Trim y normalizar espacios\n  return sanitized.trim().replace(/\\s+/g, ' ');\n};\n\n/**\n * Sanitizar entrada HTML\n */\nexport const sanitizeHTML = (input) => {\n  if (typeof input !== 'string') return '';\n  \n  return simpleSanitize(input, true);\n};\n\n/**\n * Validadores específicos\n */\nexport const validators = {\n  required: (value) => ({\n    isValid: value != null && value !== '' && String(value).trim() !== '',\n    message: 'Este campo es requerido'\n  }),\n\n  email: (value) => ({\n    isValid: !value || PATTERNS.email.test(value),\n    message: 'Formato de email inválido'\n  }),\n\n  phone: (value) => ({\n    isValid: !value || PATTERNS.phone.test(value),\n    message: 'Formato de teléfono inválido'\n  }),\n\n  currency: (value) => {\n    const numValue = parseFloat(value);\n    return {\n      isValid: !value || (PATTERNS.currency.test(value) && numValue >= 0),\n      message: 'Formato de moneda inválido'\n    };\n  },\n\n  positiveNumber: (value) => {\n    const numValue = parseFloat(value);\n    return {\n      isValid: !value || (!isNaN(numValue) && numValue > 0),\n      message: 'Debe ser un número positivo'\n    };\n  },\n\n  minLength: (min) => (value) => ({\n    isValid: !value || value.length >= min,\n    message: `Mínimo ${min} caracteres`\n  }),\n\n  maxLength: (max) => (value) => ({\n    isValid: !value || value.length <= max,\n    message: `Máximo ${max} caracteres`\n  }),\n\n  pattern: (pattern, message) => (value) => ({\n    isValid: !value || pattern.test(value),\n    message\n  }),\n\n  alphanumericSpanish: (value) => ({\n    isValid: !value || PATTERNS.alphanumericSpanish.test(value),\n    message: 'Solo letras, números y espacios permitidos'\n  }),\n\n  password: (value) => ({\n    isValid: !value || PATTERNS.password.test(value),\n    message: 'La contraseña debe tener al menos 8 caracteres, una mayúscula, una minúscula, un número y un símbolo'\n  }),\n\n  url: (value) => ({\n    isValid: !value || PATTERNS.url.test(value),\n    message: 'URL inválida'\n  }),\n\n  dateRange: (startDate, endDate) => (value) => {\n    if (!value) return { isValid: true };\n    \n    const date = new Date(value);\n    const start = startDate ? new Date(startDate) : null;\n    const end = endDate ? new Date(endDate) : null;\n    \n    let isValid = true;\n    if (start && date < start) isValid = false;\n    if (end && date > end) isValid = false;\n    \n    return {\n      isValid,\n      message: `Fecha debe estar entre ${start?.toLocaleDateString()} y ${end?.toLocaleDateString()}`\n    };\n  },\n\n  custom: (validatorFn, message) => (value) => ({\n    isValid: validatorFn(value),\n    message\n  })\n};\n\n/**\n * Validar objeto completo\n */\nexport const validateObject = (data, rules) => {\n  const errors = {};\n  let isValid = true;\n\n  Object.keys(rules).forEach(field => {\n    const value = data[field];\n    const fieldRules = Array.isArray(rules[field]) ? rules[field] : [rules[field]];\n    \n    for (const rule of fieldRules) {\n      const result = rule(value);\n      if (!result.isValid) {\n        errors[field] = result.message;\n        isValid = false;\n        break; // Solo mostrar el primer error por campo\n      }\n    }\n  });\n\n  return { isValid, errors };\n};\n\n/**\n * Esquemas de validación para la aplicación financiera\n */\nexport const schemas = {\n  expense: {\n    description: [\n      validators.required,\n      validators.minLength(3),\n      validators.maxLength(100),\n      validators.alphanumericSpanish\n    ],\n    amount: [\n      validators.required,\n      validators.positiveNumber\n    ],\n    category_id: [\n      validators.required\n    ],\n    due_date: [\n      validators.dateRange(new Date(), null)\n    ]\n  },\n\n  income: {\n    description: [\n      validators.required,\n      validators.minLength(3),\n      validators.maxLength(100),\n      validators.alphanumericSpanish\n    ],\n    amount: [\n      validators.required,\n      validators.positiveNumber\n    ],\n    category_id: [\n      validators.required\n    ]\n  },\n\n  category: {\n    name: [\n      validators.required,\n      validators.minLength(2),\n      validators.maxLength(50),\n      validators.alphanumericSpanish\n    ],\n    description: [\n      validators.maxLength(200)\n    ]\n  },\n\n  user: {\n    email: [\n      validators.required,\n      validators.email\n    ],\n    password: [\n      validators.required,\n      validators.password\n    ],\n    name: [\n      validators.required,\n      validators.minLength(2),\n      validators.maxLength(50),\n      validators.pattern(/^[a-zA-ZñÑáéíóúÁÉÍÓÚ\\s]+$/, 'Solo letras y espacios')\n    ]\n  }\n};\n\n/**\n * Funciones de sanitización específicas\n */\nexport const sanitizers = {\n  expense: (data) => ({\n    description: sanitizeText(data.description),\n    amount: parseFloat(data.amount) || 0,\n    category_id: parseInt(data.category_id) || null,\n    due_date: data.due_date ? new Date(data.due_date).toISOString().split('T')[0] : null,\n    paid: Boolean(data.paid)\n  }),\n\n  income: (data) => ({\n    description: sanitizeText(data.description),\n    amount: parseFloat(data.amount) || 0,\n    category_id: parseInt(data.category_id) || null\n  }),\n\n  category: (data) => ({\n    name: sanitizeText(data.name),\n    description: sanitizeText(data.description)\n  }),\n\n  user: (data) => ({\n    email: sanitizeText(data.email).toLowerCase(),\n    name: sanitizeText(data.name),\n    // Nota: Las contraseñas nunca deben sanitizarse, solo validarse\n    password: data.password\n  })\n};\n\n/**\n * Función helper para validar y sanitizar\n */\nexport const validateAndSanitize = (data, type) => {\n  // Sanitizar primero\n  const sanitizedData = sanitizers[type] ? sanitizers[type](data) : data;\n  \n  // Luego validar\n  const schema = schemas[type];\n  if (!schema) {\n    return { isValid: true, data: sanitizedData, errors: {} };\n  }\n  \n  const validation = validateObject(sanitizedData, schema);\n  \n  return {\n    isValid: validation.isValid,\n    data: sanitizedData,\n    errors: validation.errors\n  };\n};\n\n/**\n * Rate limiting simple para formularios\n */\nclass FormRateLimit {\n  constructor() {\n    this.attempts = new Map();\n    this.cooldownPeriod = 60000; // 1 minuto\n    this.maxAttempts = 5;\n  }\n\n  canSubmit(formId) {\n    const now = Date.now();\n    const formAttempts = this.attempts.get(formId) || { count: 0, lastAttempt: 0 };\n    \n    // Reset si pasó el período de cooldown\n    if (now - formAttempts.lastAttempt > this.cooldownPeriod) {\n      formAttempts.count = 0;\n    }\n    \n    return formAttempts.count < this.maxAttempts;\n  }\n\n  recordAttempt(formId) {\n    const now = Date.now();\n    const formAttempts = this.attempts.get(formId) || { count: 0, lastAttempt: 0 };\n    \n    formAttempts.count++;\n    formAttempts.lastAttempt = now;\n    \n    this.attempts.set(formId, formAttempts);\n  }\n\n  getRemainingCooldown(formId) {\n    const formAttempts = this.attempts.get(formId);\n    if (!formAttempts || formAttempts.count < this.maxAttempts) {\n      return 0;\n    }\n    \n    const elapsed = Date.now() - formAttempts.lastAttempt;\n    return Math.max(0, this.cooldownPeriod - elapsed);\n  }\n}\n\nexport const formRateLimit = new FormRateLimit();\n\nexport default {\n  sanitizeText,\n  sanitizeHTML,\n  validators,\n  validateObject,\n  schemas,\n  sanitizers,\n  validateAndSanitize,\n  formRateLimit\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}